import type { ChatCompletionMessageParam } from "openai/resources/chat/completions";
import { aiFunctionExecuter } from "./function-calls";
import { isContentAllowed } from "./content-filter";
import { classifyMessage } from "./message-classifier";
import { classifyFunctionMessage } from "./function-classifier";
import log from "../../log";
import { askKnowledge } from "../knowledge/search";
import type { GenericFormEntry, ServerChatItem } from "./shared-types";
import type { Message } from "../standard";

/**
 * A small in memory chat history for the function chat.
 */
const globalChatHistory = new Map<
  string,
  {
    messages: ChatCompletionMessageParam[];
    state: {
      functionModeActive?: boolean;
      knowledgeModeActive?: boolean;
    };
  }
>();

/**
 * Get the chat history for a chatId
 */
const getChatHistory = (chatId: string) => {
  return (
    globalChatHistory.get(chatId) ?? {
      messages: [],
      state: {},
    }
  );
};

/**
 * Set the chat history for a chatId
 */
const setChatHistory = (
  chatId: string,
  chatHistory: {
    messages: ChatCompletionMessageParam[];
    state: {
      functionModeActive?: boolean;
      knowledgeModeActive?: boolean;
    };
  }
) => {
  globalChatHistory.set(chatId, chatHistory);
};

type ChatState = {
  functionModeActive?: boolean;
  knowledgeModeActive?: boolean;
};

/**
 * Append to the chat history for a chatId
 */
const appendToChatHistory = (
  chatId: string,
  message: ChatCompletionMessageParam
) => {
  const currentHistory = getChatHistory(chatId);
  currentHistory.messages.push(message);
  globalChatHistory.set(chatId, currentHistory);
  return getChatHistory(chatId);
};

/**
 * Set the state of the chat
 */
const setChatState = (chatId: string, state: keyof ChatState) => {
  const currentHistory = getChatHistory(chatId);
  currentHistory.state[state] = true;
  setChatHistory(chatId, currentHistory);
  return getChatHistory(chatId);
};

/**
 * A function to set a exting chat history
 * in the store with a new ID
 */
export const setChatHistoryInServer = (
  chatHistory: Message[],
  chatId: string = ""
) => {
  if (chatId === "") chatId = generateId();
  setChatHistory(chatId, {
    messages: chatHistory as ChatCompletionMessageParam[],
    state: {},
  });
  return chatId;
};

/**
 * Overwrite the chat messages
 */
const overwriteChatMessages = (
  chatId: string,
  messages: ChatCompletionMessageParam[]
) => {
  const currentHistory = getChatHistory(chatId);
  setChatHistory(chatId, {
    messages,
    state: currentHistory.state,
  });
  return getChatHistory(chatId);
};

/**
 * Return helper function
 * Will add the return message to the chat history and return it to the UI
 */
const backToUser = (
  data: ServerChatItem,
  resetHistory?: boolean
): ServerChatItem => {
  logWithChatId(data.chatId, data.content);
  if (!resetHistory) {
    appendToChatHistory(data.chatId, {
      role: "assistant",
      content: data.content,
    });
  } else {
    setChatHistory(data.chatId, {
      messages: [],
      state: {},
    });
  }
  return data;
};

/**
 * Generate a random id for the chat session
 */
const generateId = () => {
  return Math.random().toString(36).substring(2, 15);
};

const logWithChatId = async (chatId: string, ...messages: string[]) => {
  await log.debug(`(${chatId}) ${messages.join(" ")}`);
};

/**
 * MAIN FUNCTION
 * Handles the chat with the user.
 * The server can cache the chat history by providing a chatId.
 * The chatId can be generated by the client or by the server.
 * - will check if the message is allowed
 * - will classify the message (function or knowledge)
 * - will execute the function or answer the knowledge question
 */
export const functionChat = async (
  chatId: string | undefined,
  messages: ChatCompletionMessageParam[]
) => {
  // Generate a new chatId if none is provided
  if (!chatId) {
    chatId = generateId();
    await logWithChatId(chatId, "No chatId provided, generating new chatId");
    globalChatHistory.set(chatId, {
      messages: [],
      state: {},
    });
  }

  // append global system prompt to the chat history if it is the first user message
  let chatHistory = getChatHistory(chatId);
  if (chatHistory.messages.length === 0) {
    chatHistory = overwriteChatMessages(chatId, [...messages]);
  } else {
    // append the last user message to the chat history
    appendToChatHistory(chatId, messages[messages.length - 1]);
  }

  // log the chat history for debugging purposes
  await logWithChatId(
    chatId,
    `Read ChatHistory. Length: ${chatHistory.messages.length}, state: ${JSON.stringify(chatHistory.state)}`
  );
  await log.logAChat(chatId, ...chatHistory.messages);

  try {
    const isAllowed = true; //await isContentAllowed(lastUserMessage);
    if (!isAllowed) {
      return backToUser({
        chatId,
        role: "assistant",
        content: "I´m sorry, but I can´t answer that question.",
        renderType: "text",
      });
    }

    // Classify the message. But only if the actual chat state is not already known.
    if (Object.keys(chatHistory.state).length === 0) {
      const messageType = await classifyMessage(
        chatHistory.messages[chatHistory.messages.length - 1].content as string
      );
      if (messageType === "knowledge") {
        setChatState(chatId, "knowledgeModeActive");
      } else if (messageType === "function") {
        setChatState(chatId, "functionModeActive");
      }
      await logWithChatId(chatId, "messageType", messageType);
    }

    // Handle knowledge messages
    if (chatHistory.state.knowledgeModeActive) {
      const response = await askKnowledge({
        question: messages[messages.length - 1].content as string,
        countChunks: 5,
        addBeforeN: 2,
        addAfterN: 2,
      });
      return backToUser(
        {
          chatId,
          role: "assistant",
          content: response.answer,
          renderType: "box",
          type: "info",
        },
        true
      );
    }

    // check if the message call has all necessary fields and if a function was detected
    const funcClassification = await classifyFunctionMessage(
      chatHistory.messages
    );
    overwriteChatMessages(chatId, funcClassification.messages);
    await logWithChatId(
      chatId,
      "function classification:",
      JSON.stringify(funcClassification.data)
    );

    // Was a function call detected with a known function call?
    // If not, we will reset the chat history and ask the user to try again with another prompt.
    if (funcClassification.data.functionName === "unknown") {
      return backToUser(
        {
          chatId,
          role: "assistant",
          content:
            "I am sorry. I don´t have a function that could solve your request. Please try again with another prompt.",
          renderType: "text",
        },
        true
      );
    }

    // All other functions should be executable. We will try to handle them here.
    setChatState(chatId, "functionModeActive");

    if (funcClassification.data.missingFields.length === 0) {
      const functionCall = {
        name: funcClassification.data.functionName,
        arguments: funcClassification.data.knownFields,
      };
      const functionResponse = await aiFunctionExecuter(
        functionCall.name,
        funcClassification.data.knownFields
      ).catch(async (e) => {
        await logWithChatId(chatId!, "Error executing function", e);
        throw e;
      });
      logWithChatId(
        chatId,
        "functionResponse",
        JSON.stringify(functionResponse)
      );

      // back to the user. Reset the chat history to start a new one since it can make problems
      // if different questions and actions are handled in the same chat.
      return backToUser(
        {
          chatId,
          role: "assistant",
          content: functionResponse.message,
          renderType: "text",
        },
        true
      );
    }

    // If we reach this point, we have a function call with missing fields.
    // We will return a message asking the user to provide the missing fields.
    else {
      // Create form definition from missing fields
      const formDefinition: GenericFormEntry[] =
        funcClassification.data.missingFields.map((field) => ({
          type: "text",
          label: field,
          key: field,
        }));

      // Create an object with missing fields as keys and empty strings as values
      const missingFieldsData = Object.fromEntries(
        funcClassification.data.missingFields.map((field) => [field, ""])
      );

      return backToUser({
        chatId,
        role: "assistant",
        content: "Please provide more information.",
        renderType: "form",
        definition: formDefinition,
        data: missingFieldsData,
      });
    }
  } catch (error) {
    await logWithChatId(chatId, "Error in chat endpoint:", error + "");
    return backToUser({
      chatId,
      role: "assistant",
      content: "An error occurred while processing your request. " + error,
      renderType: "text",
    });
  }
};
